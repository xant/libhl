<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>libhl: src/binheap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libhl
   </div>
   <div id="projectbrief">A collection of C libraries : thread-safe hashtables, thread-safe linklists, lock-free queues, flat buffers, ring buffers, refcounting</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('binheap_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">binheap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Binomial Heap.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="comparators_8h_source.html">comparators.h</a>&gt;</code><br/>
</div>
<p><a href="binheap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structbinheap__callbacks__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a></td></tr>
<tr class="separator:structbinheap__callbacks__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a996b18d437efeba2d2cedca7d21aa544"><td class="memItemLeft" align="right" valign="top">typedef struct __binheap_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a></td></tr>
<tr class="memdesc:a996b18d437efeba2d2cedca7d21aa544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque structure representing the heap.  <a href="#a996b18d437efeba2d2cedca7d21aa544">More...</a><br/></td></tr>
<tr class="separator:a996b18d437efeba2d2cedca7d21aa544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4809e06c94bcb9d2569d8d19dc3a2d1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#af4809e06c94bcb9d2569d8d19dc3a2d1">binheap_incr_key_callback</a> )(void *key, size_t keysize, void **new_key, size_t *new_keysize, int increment)</td></tr>
<tr class="memdesc:af4809e06c94bcb9d2569d8d19dc3a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to increment a given key by an arbitrary amount.  <a href="#af4809e06c94bcb9d2569d8d19dc3a2d1">More...</a><br/></td></tr>
<tr class="separator:af4809e06c94bcb9d2569d8d19dc3a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8fbd1a16e176618a72cefd5e842ba1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a4b8fbd1a16e176618a72cefd5e842ba1">binheap_decr_key_callback</a> )(void *key, size_t keysize, void **new_key, size_t *new_keysize, int decrement)</td></tr>
<tr class="memdesc:a4b8fbd1a16e176618a72cefd5e842ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to decrement a given key by an arbitrary amount.  <a href="#a4b8fbd1a16e176618a72cefd5e842ba1">More...</a><br/></td></tr>
<tr class="separator:a4b8fbd1a16e176618a72cefd5e842ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaf1039d6f4980dfea42a640506ceb0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a6eaf1039d6f4980dfea42a640506ceb0">binheap_walk_callback_t</a> )(<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, void *value, void *priv)</td></tr>
<tr class="memdesc:a6eaf1039d6f4980dfea42a640506ceb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called for each node when walking the priority queue.  <a href="#a6eaf1039d6f4980dfea42a640506ceb0">More...</a><br/></td></tr>
<tr class="separator:a6eaf1039d6f4980dfea42a640506ceb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a742affb06865627d216e6b001a7694f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7">binheap_mode_t</a> { <a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7adb9c014247ac0e580c7c3156e093910d">BINHEAP_MODE_MAX</a>, 
<a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7aa15e68c78c041cdd4363de055e242f53">BINHEAP_MODE_MIN</a>
 }</td></tr>
<tr class="memdesc:a742affb06865627d216e6b001a7694f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Working modes (max-based or min-based)  <a href="binheap_8h.html#a742affb06865627d216e6b001a7694f7">More...</a><br/></td></tr>
<tr class="separator:a742affb06865627d216e6b001a7694f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad1d7b1dd2c965385b60953890cbffd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ad1d7b1dd2c965385b60953890cbffd77">binheap_create</a> (const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *keys_callbacks, <a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7">binheap_mode_t</a> mode)</td></tr>
<tr class="memdesc:ad1d7b1dd2c965385b60953890cbffd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new binomial heap.  <a href="#ad1d7b1dd2c965385b60953890cbffd77">More...</a><br/></td></tr>
<tr class="separator:ad1d7b1dd2c965385b60953890cbffd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19700a45f509b2fd305dcaf68b0a196c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a19700a45f509b2fd305dcaf68b0a196c">binheap_destroy</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh)</td></tr>
<tr class="memdesc:a19700a45f509b2fd305dcaf68b0a196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all the resources used by a binomial heap.  <a href="#a19700a45f509b2fd305dcaf68b0a196c">More...</a><br/></td></tr>
<tr class="separator:a19700a45f509b2fd305dcaf68b0a196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7646d9337a931b7b17a7ca073387b114"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a7646d9337a931b7b17a7ca073387b114">binheap_insert</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, void *value)</td></tr>
<tr class="memdesc:a7646d9337a931b7b17a7ca073387b114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new value into the heap.  <a href="#a7646d9337a931b7b17a7ca073387b114">More...</a><br/></td></tr>
<tr class="separator:a7646d9337a931b7b17a7ca073387b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a28963e63622eefabae28b2b199e75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ab0a28963e63622eefabae28b2b199e75">binheap_minimum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void **key, size_t *klen, void **value)</td></tr>
<tr class="memdesc:ab0a28963e63622eefabae28b2b199e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the minimum item in the heap.  <a href="#ab0a28963e63622eefabae28b2b199e75">More...</a><br/></td></tr>
<tr class="separator:ab0a28963e63622eefabae28b2b199e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560075eea7b8d29e51569d11f14fe5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a8560075eea7b8d29e51569d11f14fe5f">binheap_maximum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void **key, size_t *klen, void **value)</td></tr>
<tr class="memdesc:a8560075eea7b8d29e51569d11f14fe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the maximum item in the heap.  <a href="#a8560075eea7b8d29e51569d11f14fe5f">More...</a><br/></td></tr>
<tr class="separator:a8560075eea7b8d29e51569d11f14fe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5937d1ceec64824853ec1a3d969e987c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a5937d1ceec64824853ec1a3d969e987c">binheap_delete_minimum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void **value)</td></tr>
<tr class="memdesc:a5937d1ceec64824853ec1a3d969e987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the minimum item in the heap (and eventually retrieve its value)  <a href="#a5937d1ceec64824853ec1a3d969e987c">More...</a><br/></td></tr>
<tr class="separator:a5937d1ceec64824853ec1a3d969e987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a0ecbe800418749dab0d43ddd546e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a431a0ecbe800418749dab0d43ddd546e">binheap_delete_maximum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void **value)</td></tr>
<tr class="memdesc:a431a0ecbe800418749dab0d43ddd546e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the maximum item in the heap (and eventually retrieve its value)  <a href="#a431a0ecbe800418749dab0d43ddd546e">More...</a><br/></td></tr>
<tr class="separator:a431a0ecbe800418749dab0d43ddd546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbde52ba6c5762afcd6803a87b2b2bff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#adbde52ba6c5762afcd6803a87b2b2bff">binheap_delete</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, void **value)</td></tr>
<tr class="memdesc:adbde52ba6c5762afcd6803a87b2b2bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete at most one item matching a given key in the heap.  <a href="#adbde52ba6c5762afcd6803a87b2b2bff">More...</a><br/></td></tr>
<tr class="separator:adbde52ba6c5762afcd6803a87b2b2bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c5240484646bdfe4fbeda64efe13a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a36c5240484646bdfe4fbeda64efe13a6">binheap_increase_minimum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, int incr)</td></tr>
<tr class="memdesc:a36c5240484646bdfe4fbeda64efe13a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the minimum key by an arbitrary amount.  <a href="#a36c5240484646bdfe4fbeda64efe13a6">More...</a><br/></td></tr>
<tr class="separator:a36c5240484646bdfe4fbeda64efe13a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f39cc407f8d86e5436ae90174d6b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a38f39cc407f8d86e5436ae90174d6b68">binheap_increase_maximum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, int incr)</td></tr>
<tr class="memdesc:a38f39cc407f8d86e5436ae90174d6b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the maximum key by an arbitrary amount.  <a href="#a38f39cc407f8d86e5436ae90174d6b68">More...</a><br/></td></tr>
<tr class="separator:a38f39cc407f8d86e5436ae90174d6b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f08473fb897257daec11703acf83d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a643f08473fb897257daec11703acf83d">binheap_decrease_minimum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, int decr)</td></tr>
<tr class="memdesc:a643f08473fb897257daec11703acf83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the minimum key by an arbitrary amount.  <a href="#a643f08473fb897257daec11703acf83d">More...</a><br/></td></tr>
<tr class="separator:a643f08473fb897257daec11703acf83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2003e2ce3d254bceb63a8a12df22b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a3c2003e2ce3d254bceb63a8a12df22b9">binheap_decrease_maximum</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, int decr)</td></tr>
<tr class="memdesc:a3c2003e2ce3d254bceb63a8a12df22b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the maximum key by an arbitrary amount.  <a href="#a3c2003e2ce3d254bceb63a8a12df22b9">More...</a><br/></td></tr>
<tr class="separator:a3c2003e2ce3d254bceb63a8a12df22b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dee194e7bd6dbd21ef6d256a9e6520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ad9dee194e7bd6dbd21ef6d256a9e6520">binheap_increase_key</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, int incr)</td></tr>
<tr class="memdesc:ad9dee194e7bd6dbd21ef6d256a9e6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase a given key by an arbitrary amount.  <a href="#ad9dee194e7bd6dbd21ef6d256a9e6520">More...</a><br/></td></tr>
<tr class="separator:ad9dee194e7bd6dbd21ef6d256a9e6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4170563eca3188a231a716f6bdf2c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ab4170563eca3188a231a716f6bdf2c73">binheap_decrease_key</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, int decr)</td></tr>
<tr class="memdesc:ab4170563eca3188a231a716f6bdf2c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease a given key by an arbitrary amount.  <a href="#ab4170563eca3188a231a716f6bdf2c73">More...</a><br/></td></tr>
<tr class="separator:ab4170563eca3188a231a716f6bdf2c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ae86c3af700313d1a1689df61c12f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a12ae86c3af700313d1a1689df61c12f0">binheap_merge</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh1, <a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh2)</td></tr>
<tr class="memdesc:a12ae86c3af700313d1a1689df61c12f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two heaps.  <a href="#a12ae86c3af700313d1a1689df61c12f0">More...</a><br/></td></tr>
<tr class="separator:a12ae86c3af700313d1a1689df61c12f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde2fb22431b163d45f77ca433c878c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#adcde2fb22431b163d45f77ca433c878c">binheap_walk</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, <a class="el" href="binheap_8h.html#a6eaf1039d6f4980dfea42a640506ceb0">binheap_walk_callback_t</a> cb, void *priv)</td></tr>
<tr class="memdesc:adcde2fb22431b163d45f77ca433c878c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the entire priority queue and call the provided callback for each visited node.  <a href="#adcde2fb22431b163d45f77ca433c878c">More...</a><br/></td></tr>
<tr class="separator:adcde2fb22431b163d45f77ca433c878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa733db191b87bf6bb2b9f246d9c23348"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#aa733db191b87bf6bb2b9f246d9c23348">binheap_count</a> (<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh)</td></tr>
<tr class="memdesc:aa733db191b87bf6bb2b9f246d9c23348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the heap.  <a href="#aa733db191b87bf6bb2b9f246d9c23348">More...</a><br/></td></tr>
<tr class="separator:aa733db191b87bf6bb2b9f246d9c23348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7417981b93895ad623a7fbca4b858acf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a7417981b93895ad623a7fbca4b858acf">binheap_keys_callbacks_int16_t</a> ()</td></tr>
<tr class="memdesc:a7417981b93895ad623a7fbca4b858acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 16bit signed integer keys.  <a href="#a7417981b93895ad623a7fbca4b858acf">More...</a><br/></td></tr>
<tr class="separator:a7417981b93895ad623a7fbca4b858acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb4890a1e3835d51873cc496ddd7ae0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a1eb4890a1e3835d51873cc496ddd7ae0">binheap_keys_callbacks_int32_t</a> ()</td></tr>
<tr class="memdesc:a1eb4890a1e3835d51873cc496ddd7ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 32bit signed integer keys.  <a href="#a1eb4890a1e3835d51873cc496ddd7ae0">More...</a><br/></td></tr>
<tr class="separator:a1eb4890a1e3835d51873cc496ddd7ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490f0983a7753466835e1fad2e21a2a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ad490f0983a7753466835e1fad2e21a2a">binheap_keys_callbacks_int64_t</a> ()</td></tr>
<tr class="memdesc:ad490f0983a7753466835e1fad2e21a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 64bit signed integer keys.  <a href="#ad490f0983a7753466835e1fad2e21a2a">More...</a><br/></td></tr>
<tr class="separator:ad490f0983a7753466835e1fad2e21a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030c1e1b0d33724e1e49089cd4883533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a030c1e1b0d33724e1e49089cd4883533">binheap_keys_callbacks_uint16_t</a> ()</td></tr>
<tr class="memdesc:a030c1e1b0d33724e1e49089cd4883533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 16bit unsigned integer keys.  <a href="#a030c1e1b0d33724e1e49089cd4883533">More...</a><br/></td></tr>
<tr class="separator:a030c1e1b0d33724e1e49089cd4883533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a629ec0c95b9a859de193e69e88910e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a4a629ec0c95b9a859de193e69e88910e">binheap_keys_callbacks_uint32_t</a> ()</td></tr>
<tr class="memdesc:a4a629ec0c95b9a859de193e69e88910e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 32bit unsigned integer keys.  <a href="#a4a629ec0c95b9a859de193e69e88910e">More...</a><br/></td></tr>
<tr class="separator:a4a629ec0c95b9a859de193e69e88910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305679dbcb981392d4f2d4efc61fde37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a305679dbcb981392d4f2d4efc61fde37">binheap_keys_callbacks_uint64_t</a> ()</td></tr>
<tr class="memdesc:a305679dbcb981392d4f2d4efc61fde37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle 64bit unsigned integer keys.  <a href="#a305679dbcb981392d4f2d4efc61fde37">More...</a><br/></td></tr>
<tr class="separator:a305679dbcb981392d4f2d4efc61fde37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16dcffaa7f68487b68636dd4996627d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#ac16dcffaa7f68487b68636dd4996627d">binheap_keys_callbacks_float</a> ()</td></tr>
<tr class="memdesc:ac16dcffaa7f68487b68636dd4996627d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle float keys.  <a href="#ac16dcffaa7f68487b68636dd4996627d">More...</a><br/></td></tr>
<tr class="separator:ac16dcffaa7f68487b68636dd4996627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2516e9d1fe4164c5d40ee65e528ab4b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binheap_8h.html#a2516e9d1fe4164c5d40ee65e528ab4b3">binheap_keys_callbacks_double</a> ()</td></tr>
<tr class="memdesc:a2516e9d1fe4164c5d40ee65e528ab4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callbacks to handle double keys.  <a href="#a2516e9d1fe4164c5d40ee65e528ab4b3">More...</a><br/></td></tr>
<tr class="separator:a2516e9d1fe4164c5d40ee65e528ab4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Binomial Heap. </p>
<p>Binomial Heap implementation for arbitrary data</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implement <a class="el" href="binheap_8h.html#ad9dee194e7bd6dbd21ef6d256a9e6520" title="Increase a given key by an arbitrary amount. ">binheap_increase_key()</a> and <a class="el" href="binheap_8h.html#ab4170563eca3188a231a716f6bdf2c73" title="Decrease a given key by an arbitrary amount. ">binheap_decrease_key()</a></dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structbinheap__callbacks__t" id="structbinheap__callbacks__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct binheap_callbacks_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a12ff90b7a19a8b9d70d6c43f18b82621"></a><a class="el" href="comparators_8h.html#ae449dfb37b34f92e03af505cf97eaeb9">libhl_cmp_callback_t</a></td>
<td class="fieldname">
cmp</td>
<td class="fielddoc">
compare two keys </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aada8544b7a9ef937ea8d031910ca9aea"></a><a class="el" href="binheap_8h.html#af4809e06c94bcb9d2569d8d19dc3a2d1">binheap_incr_key_callback</a></td>
<td class="fieldname">
incr</td>
<td class="fielddoc">
increment a given key </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a155f5635a59c09bbf6fb82e576b0d019"></a><a class="el" href="binheap_8h.html#a4b8fbd1a16e176618a72cefd5e842ba1">binheap_decr_key_callback</a></td>
<td class="fieldname">
decr</td>
<td class="fielddoc">
decrement a given key </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a996b18d437efeba2d2cedca7d21aa544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct __binheap_s <a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque structure representing the heap. </p>

</div>
</div>
<a class="anchor" id="af4809e06c94bcb9d2569d8d19dc3a2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* binheap_incr_key_callback)(void *key, size_t keysize, void **new_key, size_t *new_keysize, int increment)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to increment a given key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to increment </td></tr>
    <tr><td class="paramname">keysize</td><td>The size of the key </td></tr>
    <tr><td class="paramname">new_key</td><td>If NOT-NULL will be set to point to the new memory where the incremented key is stored. The caller will be responsible of releasing the memory allocated for the new key </td></tr>
    <tr><td class="paramname">new_keysize</td><td>If NOT-NULL the memory pointed by new_keysize will be set to the size of the memory holding the new_key </td></tr>
    <tr><td class="paramname">increment</td><td>How much to increment the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b8fbd1a16e176618a72cefd5e842ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* binheap_decr_key_callback)(void *key, size_t keysize, void **new_key, size_t *new_keysize, int decrement)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to decrement a given key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to decrement </td></tr>
    <tr><td class="paramname">keysize</td><td>The size of the key </td></tr>
    <tr><td class="paramname">new_key</td><td>If NOT-NULL will be set to point to the new memory where the incremented key is stored. The caller will be responsible of releasing the memory allocated for the new key </td></tr>
    <tr><td class="paramname">new_keysize</td><td>If NOT-NULL the memory pointed by new_keysize will be set to the size of the memory holding the new_key </td></tr>
    <tr><td class="paramname">decrement</td><td>How much to decrement the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eaf1039d6f4980dfea42a640506ceb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* binheap_walk_callback_t)(<a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *bh, void *key, size_t klen, void *value, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback called for each node when walking the priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>The key of the current node </td></tr>
    <tr><td class="paramname">klen</td><td>The size of the key </td></tr>
    <tr><td class="paramname">value</td><td>The value of the current node </td></tr>
    <tr><td class="paramname">priv</td><td>The private pointer passed to <a class="el" href="binheap_8h.html#adcde2fb22431b163d45f77ca433c878c" title="Walk the entire priority queue and call the provided callback for each visited node. ">binheap_walk()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 If the walker can go ahead visiting the next node, 0 if the walker should stop and return -1 if the current node should be removed and the walker can go ahead -2 if the current node should be removed and the walker should stop </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a742affb06865627d216e6b001a7694f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7">binheap_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Working modes (max-based or min-based) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a742affb06865627d216e6b001a7694f7adb9c014247ac0e580c7c3156e093910d"></a>BINHEAP_MODE_MAX</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a742affb06865627d216e6b001a7694f7aa15e68c78c041cdd4363de055e242f53"></a>BINHEAP_MODE_MIN</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad1d7b1dd2c965385b60953890cbffd77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a>* binheap_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> *&#160;</td>
          <td class="paramname"><em>keys_callbacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a742affb06865627d216e6b001a7694f7">binheap_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new binomial heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_callbacks</td><td>A pointer to the <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a> structure holding the callbacks used for key management (compare/increment/decrement) </td></tr>
    <tr><td class="paramname">mode</td><td>The operational mode: BINHEAP_MODE_MAX or BINHEAP_MODE_MIN which will determines if parents are bigger than children in the internal binomial tree or viceversa (parents are smaller than children). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The difference between using BINHEAP_MODE_MAX and BINHEAP_MODE_MIN is basically in complexity when extracting the maximum or the minimum value:<br/>
<ul>
<li>accessing the maximum value is a O(1) operation in BINHEAP_MODE_MAX,<br/>
 a O(logn) operation in BINHEAP_MODE_MIN<br/>
</li>
<li>accessing the minimum value is a O(logn) operation in BINHEAP_MODE_MAX,<br/>
 a O(1) operation in BINHEAP_MODE_MIN<br/>
 </li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A valid and initialized binomial heap (empty) </dd></dl>

</div>
</div>
<a class="anchor" id="a19700a45f509b2fd305dcaf68b0a196c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all the resources used by a binomial heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7646d9337a931b7b17a7ca073387b114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new value into the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>The key of the node where to store the new value </td></tr>
    <tr><td class="paramname">klen</td><td>The size of the key </td></tr>
    <tr><td class="paramname">value</td><td>The new value to store </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if a new node has been inserted successfully; -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a28963e63622eefabae28b2b199e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the minimum item in the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>If not null will be set to point to the minimum key in the heap </td></tr>
    <tr><td class="paramname">klen</td><td>If not null will be set to point to the size of the key </td></tr>
    <tr><td class="paramname">value</td><td>If not null will be set to point to the value for the minimum item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the minimum item has been successfully found,<br/>
 -1 in case of errors </dd></dl>

</div>
</div>
<a class="anchor" id="a8560075eea7b8d29e51569d11f14fe5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the maximum item in the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>If not null will be set to point to the maximum key in the heap </td></tr>
    <tr><td class="paramname">klen</td><td>If not null will be set to point to the size of the key </td></tr>
    <tr><td class="paramname">value</td><td>If not null will be set to point to the value for the maximum item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the maximum item has been successfully found,<br/>
 -1 in case of errors </dd></dl>

</div>
</div>
<a class="anchor" id="a5937d1ceec64824853ec1a3d969e987c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_delete_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the minimum item in the heap (and eventually retrieve its value) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">value</td><td>If not null will be set to point to the value for the minimum item being removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the minimum item has been found and removed successfully,<br/>
 -1 in case of errors </dd></dl>

</div>
</div>
<a class="anchor" id="a431a0ecbe800418749dab0d43ddd546e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_delete_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the maximum item in the heap (and eventually retrieve its value) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">value</td><td>If not null will be set to point to the value for the maximum item being removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the minimum item has been found and removed successfully,<br/>
 -1 in case of errors </dd></dl>

</div>
</div>
<a class="anchor" id="adbde52ba6c5762afcd6803a87b2b2bff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete at most one item matching a given key in the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>The key to match </td></tr>
    <tr><td class="paramname">klen</td><td>The size of the key </td></tr>
    <tr><td class="paramname">value</td><td>If not null will be set to point to the value for the maximum item being removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if least one item has been found matching the given key and it has been removed successfully,<br/>
 -1 in case of errors </dd></dl>

</div>
</div>
<a class="anchor" id="a36c5240484646bdfe4fbeda64efe13a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_increase_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the minimum key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">incr</td><td>The amount to increase the minimum key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38f39cc407f8d86e5436ae90174d6b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_increase_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the maximum key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">incr</td><td>The amount to increase the maximum key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a643f08473fb897257daec11703acf83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_decrease_minimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the minimum key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">decr</td><td>The amount to decrease the minimum key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c2003e2ce3d254bceb63a8a12df22b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_decrease_maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the maximum key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">decr</td><td>The amount to decrease the maximum key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9dee194e7bd6dbd21ef6d256a9e6520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_increase_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase a given key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">key</td><td>The key to increase </td></tr>
    <tr><td class="paramname">klen</td><td>The size of the key </td></tr>
    <tr><td class="paramname">incr</td><td>The amount to increase the key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4170563eca3188a231a716f6bdf2c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binheap_decrease_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>klen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease a given key by an arbitrary amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to increase </td></tr>
    <tr><td class="paramname">klen</td><td>The size of the key </td></tr>
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">decr</td><td>The amount to decrease the key by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12ae86c3af700313d1a1689df61c12f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a>* binheap_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two heaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh1</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">bh2</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created heap which will contain the union of the items stored in both the heaps (bh1 and bh2) provided as argument. The caller is responsible of disposing the new heap. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Both bh1 and bh2 will be empty once merged in the new returned heap. The caller is responsible of disposing both of them if not necessary anymore (otherwise further operations on the original heaps are still possible) </dd>
<dd>
The two heaps MUST be configured to use the same operational mode for them to be merged. If the operational modes differ no merge will be attempted and NULL will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="adcde2fb22431b163d45f77ca433c878c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binheap_walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a6eaf1039d6f4980dfea42a640506ceb0">binheap_walk_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>priv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk the entire priority queue and call the provided callback for each visited node. </p>
<dl class="section note"><dt>Note</dt><dd>The callback can both stop the walker and/or remove the currently visited node using its return value (check binheap_walk_callback_t) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to call for each visited node </td></tr>
    <tr><td class="paramname">priv</td><td>A private pointer which will be passed to the callback at each call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of visited nodes </dd></dl>

</div>
</div>
<a class="anchor" id="aa733db191b87bf6bb2b9f246d9c23348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t binheap_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="binheap_8h.html#a996b18d437efeba2d2cedca7d21aa544">binheap_t</a> *&#160;</td>
          <td class="paramname"><em>bh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of items in the heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bh</td><td>A valid pointer to an initialized binheap_t structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of items in the heap </dd></dl>

</div>
</div>
<a class="anchor" id="a7417981b93895ad623a7fbca4b858acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_int16_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 16bit signed integer keys. </p>

</div>
</div>
<a class="anchor" id="a1eb4890a1e3835d51873cc496ddd7ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_int32_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 32bit signed integer keys. </p>

</div>
</div>
<a class="anchor" id="ad490f0983a7753466835e1fad2e21a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_int64_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 64bit signed integer keys. </p>

</div>
</div>
<a class="anchor" id="a030c1e1b0d33724e1e49089cd4883533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_uint16_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 16bit unsigned integer keys. </p>

</div>
</div>
<a class="anchor" id="a4a629ec0c95b9a859de193e69e88910e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_uint32_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 32bit unsigned integer keys. </p>

</div>
</div>
<a class="anchor" id="a305679dbcb981392d4f2d4efc61fde37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_uint64_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle 64bit unsigned integer keys. </p>

</div>
</div>
<a class="anchor" id="ac16dcffaa7f68487b68636dd4996627d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle float keys. </p>

</div>
</div>
<a class="anchor" id="a2516e9d1fe4164c5d40ee65e528ab4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="binheap_8h.html#structbinheap__callbacks__t">binheap_callbacks_t</a>* binheap_keys_callbacks_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callbacks to handle double keys. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="binheap_8h.html">binheap.h</a></li>
    <li class="footer">Generated on Fri Dec 19 2014 10:27:28 for libhl by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
